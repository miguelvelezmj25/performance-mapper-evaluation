//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.10-b140310.1920 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2018.09.14 at 01:47:22 PM EDT 
//


package org.apache.activemq.schema.core;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyAttribute;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementRefs;
import javax.xml.bind.annotation.XmlID;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.CollapsedStringAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.namespace.QName;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;choice maxOccurs="unbounded" minOccurs="0">
 *         &lt;choice>
 *           &lt;element name="blobTransferPolicy" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="clientIdGenerator" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="clientInternalExceptionListener" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="connectionIdGenerator" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="exceptionListener" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="prefetchPolicy" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;choice minOccurs="0">
 *                     &lt;element ref="{http://activemq.apache.org/schema/core}prefetchPolicy"/>
 *                     &lt;any namespace='##other'/>
 *                   &lt;/choice>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="properties" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="redeliveryPolicy" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;choice minOccurs="0">
 *                     &lt;element ref="{http://activemq.apache.org/schema/core}redeliveryPolicy"/>
 *                     &lt;any namespace='##other'/>
 *                   &lt;/choice>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="redeliveryPolicyMap" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;choice minOccurs="0">
 *                     &lt;element ref="{http://activemq.apache.org/schema/core}redeliveryPolicyMap"/>
 *                     &lt;any namespace='##other'/>
 *                   &lt;/choice>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="rejectedTaskHandler" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="sessionTaskRunner" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;choice minOccurs="0">
 *                     &lt;element ref="{http://activemq.apache.org/schema/core}taskRunnerFactory"/>
 *                     &lt;any namespace='##other'/>
 *                   &lt;/choice>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="transformer" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="transportListener" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;element name="trustedPackages" maxOccurs="unbounded" minOccurs="0">
 *             &lt;complexType>
 *               &lt;complexContent>
 *                 &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *                   &lt;sequence maxOccurs="unbounded" minOccurs="0">
 *                     &lt;any maxOccurs="unbounded" minOccurs="0"/>
 *                   &lt;/sequence>
 *                 &lt;/restriction>
 *               &lt;/complexContent>
 *             &lt;/complexType>
 *           &lt;/element>
 *           &lt;any namespace='##other' maxOccurs="unbounded" minOccurs="0"/>
 *         &lt;/choice>
 *       &lt;/choice>
 *       &lt;attribute name="alwaysSessionAsync" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="alwaysSyncSend" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="auditDepth" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="auditMaximumProducerNumber" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="beanName" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="blobTransferPolicy" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="brokerURL" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="checkForDuplicates" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="clientID" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="clientIDPrefix" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="clientIdGenerator" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="clientInternalExceptionListener" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="closeTimeout" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="connectResponseTimeout" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="connectionIDPrefix" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="connectionIdGenerator" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="consumerExpiryCheckEnabled" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="consumerFailoverRedeliveryWaitPeriod" type="{http://www.w3.org/2001/XMLSchema}long" />
 *       &lt;attribute name="copyMessageOnSend" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="disableTimeStampsByDefault" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="dispatchAsync" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="exceptionListener" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="exclusiveConsumer" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="maxThreadPoolSize" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="messagePrioritySupported" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="nestedMapAndListEnabled" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="nonBlockingRedelivery" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="objectMessageSerializationDefered" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="optimizeAcknowledge" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="optimizeAcknowledgeTimeOut" type="{http://www.w3.org/2001/XMLSchema}long" />
 *       &lt;attribute name="optimizedAckScheduledAckInterval" type="{http://www.w3.org/2001/XMLSchema}long" />
 *       &lt;attribute name="optimizedMessageDispatch" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="password" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="prefetchPolicy" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="producerWindowSize" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="properties" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="redeliveryPolicy" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="redeliveryPolicyMap" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="rejectedTaskHandler" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="rmIdFromConnectionId" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="sendAcksAsync" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="sendTimeout" type="{http://www.w3.org/2001/XMLSchema}integer" />
 *       &lt;attribute name="sessionTaskRunner" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="statsEnabled" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="transactedIndividualAck" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="transformer" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="transportListener" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="trustAllPackages" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="useAsyncSend" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="useBeanNameAsClientIdPrefix" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="useCompression" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="useDedicatedTaskRunner" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="useRetroactiveConsumer" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="userName" type="{http://www.w3.org/2001/XMLSchema}string" />
 *       &lt;attribute name="warnAboutUnstartedConnectionTimeout" type="{http://www.w3.org/2001/XMLSchema}long" />
 *       &lt;attribute name="watchTopicAdvisories" type="{http://www.w3.org/2001/XMLSchema}boolean" />
 *       &lt;attribute name="id" type="{http://www.w3.org/2001/XMLSchema}ID" />
 *       &lt;anyAttribute processContents='lax' namespace='##other'/>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener"
})
@XmlRootElement(name = "connectionFactory")
public class DtoConnectionFactory
    implements Equals, HashCode, ToString
{

    @XmlElementRefs({
        @XmlElementRef(name = "trustedPackages", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "redeliveryPolicy", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "redeliveryPolicyMap", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "connectionIdGenerator", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "clientInternalExceptionListener", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "transportListener", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "transformer", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "blobTransferPolicy", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "prefetchPolicy", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "sessionTaskRunner", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "clientIdGenerator", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "rejectedTaskHandler", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "properties", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false),
        @XmlElementRef(name = "exceptionListener", namespace = "http://activemq.apache.org/schema/core", type = JAXBElement.class, required = false)
    })
    @XmlAnyElement(lax = true)
    protected List<Object> blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
    @XmlAttribute(name = "alwaysSessionAsync")
    protected Boolean alwaysSessionAsync;
    @XmlAttribute(name = "alwaysSyncSend")
    protected Boolean alwaysSyncSend;
    @XmlAttribute(name = "auditDepth")
    protected BigInteger auditDepth;
    @XmlAttribute(name = "auditMaximumProducerNumber")
    protected BigInteger auditMaximumProducerNumber;
    @XmlAttribute(name = "beanName")
    protected String beanName;
    @XmlAttribute(name = "blobTransferPolicy")
    protected String blobTransferPolicy;
    @XmlAttribute(name = "brokerURL")
    protected String brokerURL;
    @XmlAttribute(name = "checkForDuplicates")
    protected Boolean checkForDuplicates;
    @XmlAttribute(name = "clientID")
    protected String clientID;
    @XmlAttribute(name = "clientIDPrefix")
    protected String clientIDPrefix;
    @XmlAttribute(name = "clientIdGenerator")
    protected String clientIdGenerator;
    @XmlAttribute(name = "clientInternalExceptionListener")
    protected String clientInternalExceptionListener;
    @XmlAttribute(name = "closeTimeout")
    protected BigInteger closeTimeout;
    @XmlAttribute(name = "connectResponseTimeout")
    protected BigInteger connectResponseTimeout;
    @XmlAttribute(name = "connectionIDPrefix")
    protected String connectionIDPrefix;
    @XmlAttribute(name = "connectionIdGenerator")
    protected String connectionIdGenerator;
    @XmlAttribute(name = "consumerExpiryCheckEnabled")
    protected Boolean consumerExpiryCheckEnabled;
    @XmlAttribute(name = "consumerFailoverRedeliveryWaitPeriod")
    protected Long consumerFailoverRedeliveryWaitPeriod;
    @XmlAttribute(name = "copyMessageOnSend")
    protected Boolean copyMessageOnSend;
    @XmlAttribute(name = "disableTimeStampsByDefault")
    protected Boolean disableTimeStampsByDefault;
    @XmlAttribute(name = "dispatchAsync")
    protected Boolean dispatchAsync;
    @XmlAttribute(name = "exceptionListener")
    protected String exceptionListener;
    @XmlAttribute(name = "exclusiveConsumer")
    protected Boolean exclusiveConsumer;
    @XmlAttribute(name = "maxThreadPoolSize")
    protected BigInteger maxThreadPoolSize;
    @XmlAttribute(name = "messagePrioritySupported")
    protected Boolean messagePrioritySupported;
    @XmlAttribute(name = "nestedMapAndListEnabled")
    protected Boolean nestedMapAndListEnabled;
    @XmlAttribute(name = "nonBlockingRedelivery")
    protected Boolean nonBlockingRedelivery;
    @XmlAttribute(name = "objectMessageSerializationDefered")
    protected Boolean objectMessageSerializationDefered;
    @XmlAttribute(name = "optimizeAcknowledge")
    protected Boolean optimizeAcknowledge;
    @XmlAttribute(name = "optimizeAcknowledgeTimeOut")
    protected Long optimizeAcknowledgeTimeOut;
    @XmlAttribute(name = "optimizedAckScheduledAckInterval")
    protected Long optimizedAckScheduledAckInterval;
    @XmlAttribute(name = "optimizedMessageDispatch")
    protected Boolean optimizedMessageDispatch;
    @XmlAttribute(name = "password")
    protected String password;
    @XmlAttribute(name = "prefetchPolicy")
    protected String prefetchPolicy;
    @XmlAttribute(name = "producerWindowSize")
    protected BigInteger producerWindowSize;
    @XmlAttribute(name = "properties")
    protected String properties;
    @XmlAttribute(name = "redeliveryPolicy")
    protected String redeliveryPolicy;
    @XmlAttribute(name = "redeliveryPolicyMap")
    protected String redeliveryPolicyMap;
    @XmlAttribute(name = "rejectedTaskHandler")
    protected String rejectedTaskHandler;
    @XmlAttribute(name = "rmIdFromConnectionId")
    protected Boolean rmIdFromConnectionId;
    @XmlAttribute(name = "sendAcksAsync")
    protected Boolean sendAcksAsync;
    @XmlAttribute(name = "sendTimeout")
    protected BigInteger sendTimeout;
    @XmlAttribute(name = "sessionTaskRunner")
    protected String sessionTaskRunner;
    @XmlAttribute(name = "statsEnabled")
    protected Boolean statsEnabled;
    @XmlAttribute(name = "transactedIndividualAck")
    protected Boolean transactedIndividualAck;
    @XmlAttribute(name = "transformer")
    protected String transformer;
    @XmlAttribute(name = "transportListener")
    protected String transportListener;
    @XmlAttribute(name = "trustAllPackages")
    protected Boolean trustAllPackages;
    @XmlAttribute(name = "useAsyncSend")
    protected Boolean useAsyncSend;
    @XmlAttribute(name = "useBeanNameAsClientIdPrefix")
    protected Boolean useBeanNameAsClientIdPrefix;
    @XmlAttribute(name = "useCompression")
    protected Boolean useCompression;
    @XmlAttribute(name = "useDedicatedTaskRunner")
    protected Boolean useDedicatedTaskRunner;
    @XmlAttribute(name = "useRetroactiveConsumer")
    protected Boolean useRetroactiveConsumer;
    @XmlAttribute(name = "userName")
    protected String userName;
    @XmlAttribute(name = "warnAboutUnstartedConnectionTimeout")
    protected Long warnAboutUnstartedConnectionTimeout;
    @XmlAttribute(name = "watchTopicAdvisories")
    protected Boolean watchTopicAdvisories;
    @XmlAttribute(name = "id")
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = "ID")
    protected String id;
    @XmlAnyAttribute
    private Map<QName, String> otherAttributes = new HashMap<QName, String>();

    /**
     * Gets the value of the blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.TrustedPackages }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.RedeliveryPolicy }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.RedeliveryPolicyMap }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.ConnectionIdGenerator }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.ClientInternalExceptionListener }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.TransportListener }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.Transformer }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.BlobTransferPolicy }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.PrefetchPolicy }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.SessionTaskRunner }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.ClientIdGenerator }{@code >}
     * {@link Object }
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.RejectedTaskHandler }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.Properties }{@code >}
     * {@link JAXBElement }{@code <}{@link DtoConnectionFactory.ExceptionListener }{@code >}
     * 
     * 
     */
    public List<Object> getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener() {
        if (blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener == null) {
            blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener = new ArrayList<Object>();
        }
        return this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
    }

    /**
     * Gets the value of the alwaysSessionAsync property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isAlwaysSessionAsync() {
        return alwaysSessionAsync;
    }

    /**
     * Sets the value of the alwaysSessionAsync property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAlwaysSessionAsync(Boolean value) {
        this.alwaysSessionAsync = value;
    }

    /**
     * Gets the value of the alwaysSyncSend property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isAlwaysSyncSend() {
        return alwaysSyncSend;
    }

    /**
     * Sets the value of the alwaysSyncSend property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAlwaysSyncSend(Boolean value) {
        this.alwaysSyncSend = value;
    }

    /**
     * Gets the value of the auditDepth property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getAuditDepth() {
        return auditDepth;
    }

    /**
     * Sets the value of the auditDepth property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setAuditDepth(BigInteger value) {
        this.auditDepth = value;
    }

    /**
     * Gets the value of the auditMaximumProducerNumber property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getAuditMaximumProducerNumber() {
        return auditMaximumProducerNumber;
    }

    /**
     * Sets the value of the auditMaximumProducerNumber property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setAuditMaximumProducerNumber(BigInteger value) {
        this.auditMaximumProducerNumber = value;
    }

    /**
     * Gets the value of the beanName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getBeanName() {
        return beanName;
    }

    /**
     * Sets the value of the beanName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setBeanName(String value) {
        this.beanName = value;
    }

    /**
     * Gets the value of the blobTransferPolicy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getBlobTransferPolicy() {
        return blobTransferPolicy;
    }

    /**
     * Sets the value of the blobTransferPolicy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setBlobTransferPolicy(String value) {
        this.blobTransferPolicy = value;
    }

    /**
     * Gets the value of the brokerURL property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getBrokerURL() {
        return brokerURL;
    }

    /**
     * Sets the value of the brokerURL property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setBrokerURL(String value) {
        this.brokerURL = value;
    }

    /**
     * Gets the value of the checkForDuplicates property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isCheckForDuplicates() {
        return checkForDuplicates;
    }

    /**
     * Sets the value of the checkForDuplicates property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setCheckForDuplicates(Boolean value) {
        this.checkForDuplicates = value;
    }

    /**
     * Gets the value of the clientID property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClientID() {
        return clientID;
    }

    /**
     * Sets the value of the clientID property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClientID(String value) {
        this.clientID = value;
    }

    /**
     * Gets the value of the clientIDPrefix property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClientIDPrefix() {
        return clientIDPrefix;
    }

    /**
     * Sets the value of the clientIDPrefix property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClientIDPrefix(String value) {
        this.clientIDPrefix = value;
    }

    /**
     * Gets the value of the clientIdGenerator property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClientIdGenerator() {
        return clientIdGenerator;
    }

    /**
     * Sets the value of the clientIdGenerator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClientIdGenerator(String value) {
        this.clientIdGenerator = value;
    }

    /**
     * Gets the value of the clientInternalExceptionListener property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClientInternalExceptionListener() {
        return clientInternalExceptionListener;
    }

    /**
     * Sets the value of the clientInternalExceptionListener property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClientInternalExceptionListener(String value) {
        this.clientInternalExceptionListener = value;
    }

    /**
     * Gets the value of the closeTimeout property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getCloseTimeout() {
        return closeTimeout;
    }

    /**
     * Sets the value of the closeTimeout property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setCloseTimeout(BigInteger value) {
        this.closeTimeout = value;
    }

    /**
     * Gets the value of the connectResponseTimeout property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getConnectResponseTimeout() {
        return connectResponseTimeout;
    }

    /**
     * Sets the value of the connectResponseTimeout property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setConnectResponseTimeout(BigInteger value) {
        this.connectResponseTimeout = value;
    }

    /**
     * Gets the value of the connectionIDPrefix property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getConnectionIDPrefix() {
        return connectionIDPrefix;
    }

    /**
     * Sets the value of the connectionIDPrefix property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setConnectionIDPrefix(String value) {
        this.connectionIDPrefix = value;
    }

    /**
     * Gets the value of the connectionIdGenerator property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getConnectionIdGenerator() {
        return connectionIdGenerator;
    }

    /**
     * Sets the value of the connectionIdGenerator property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setConnectionIdGenerator(String value) {
        this.connectionIdGenerator = value;
    }

    /**
     * Gets the value of the consumerExpiryCheckEnabled property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isConsumerExpiryCheckEnabled() {
        return consumerExpiryCheckEnabled;
    }

    /**
     * Sets the value of the consumerExpiryCheckEnabled property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setConsumerExpiryCheckEnabled(Boolean value) {
        this.consumerExpiryCheckEnabled = value;
    }

    /**
     * Gets the value of the consumerFailoverRedeliveryWaitPeriod property.
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    public Long getConsumerFailoverRedeliveryWaitPeriod() {
        return consumerFailoverRedeliveryWaitPeriod;
    }

    /**
     * Sets the value of the consumerFailoverRedeliveryWaitPeriod property.
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void setConsumerFailoverRedeliveryWaitPeriod(Long value) {
        this.consumerFailoverRedeliveryWaitPeriod = value;
    }

    /**
     * Gets the value of the copyMessageOnSend property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isCopyMessageOnSend() {
        return copyMessageOnSend;
    }

    /**
     * Sets the value of the copyMessageOnSend property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setCopyMessageOnSend(Boolean value) {
        this.copyMessageOnSend = value;
    }

    /**
     * Gets the value of the disableTimeStampsByDefault property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isDisableTimeStampsByDefault() {
        return disableTimeStampsByDefault;
    }

    /**
     * Sets the value of the disableTimeStampsByDefault property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setDisableTimeStampsByDefault(Boolean value) {
        this.disableTimeStampsByDefault = value;
    }

    /**
     * Gets the value of the dispatchAsync property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isDispatchAsync() {
        return dispatchAsync;
    }

    /**
     * Sets the value of the dispatchAsync property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setDispatchAsync(Boolean value) {
        this.dispatchAsync = value;
    }

    /**
     * Gets the value of the exceptionListener property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getExceptionListener() {
        return exceptionListener;
    }

    /**
     * Sets the value of the exceptionListener property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setExceptionListener(String value) {
        this.exceptionListener = value;
    }

    /**
     * Gets the value of the exclusiveConsumer property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isExclusiveConsumer() {
        return exclusiveConsumer;
    }

    /**
     * Sets the value of the exclusiveConsumer property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setExclusiveConsumer(Boolean value) {
        this.exclusiveConsumer = value;
    }

    /**
     * Gets the value of the maxThreadPoolSize property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getMaxThreadPoolSize() {
        return maxThreadPoolSize;
    }

    /**
     * Sets the value of the maxThreadPoolSize property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setMaxThreadPoolSize(BigInteger value) {
        this.maxThreadPoolSize = value;
    }

    /**
     * Gets the value of the messagePrioritySupported property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isMessagePrioritySupported() {
        return messagePrioritySupported;
    }

    /**
     * Sets the value of the messagePrioritySupported property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setMessagePrioritySupported(Boolean value) {
        this.messagePrioritySupported = value;
    }

    /**
     * Gets the value of the nestedMapAndListEnabled property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isNestedMapAndListEnabled() {
        return nestedMapAndListEnabled;
    }

    /**
     * Sets the value of the nestedMapAndListEnabled property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setNestedMapAndListEnabled(Boolean value) {
        this.nestedMapAndListEnabled = value;
    }

    /**
     * Gets the value of the nonBlockingRedelivery property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isNonBlockingRedelivery() {
        return nonBlockingRedelivery;
    }

    /**
     * Sets the value of the nonBlockingRedelivery property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setNonBlockingRedelivery(Boolean value) {
        this.nonBlockingRedelivery = value;
    }

    /**
     * Gets the value of the objectMessageSerializationDefered property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isObjectMessageSerializationDefered() {
        return objectMessageSerializationDefered;
    }

    /**
     * Sets the value of the objectMessageSerializationDefered property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setObjectMessageSerializationDefered(Boolean value) {
        this.objectMessageSerializationDefered = value;
    }

    /**
     * Gets the value of the optimizeAcknowledge property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isOptimizeAcknowledge() {
        return optimizeAcknowledge;
    }

    /**
     * Sets the value of the optimizeAcknowledge property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setOptimizeAcknowledge(Boolean value) {
        this.optimizeAcknowledge = value;
    }

    /**
     * Gets the value of the optimizeAcknowledgeTimeOut property.
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    public Long getOptimizeAcknowledgeTimeOut() {
        return optimizeAcknowledgeTimeOut;
    }

    /**
     * Sets the value of the optimizeAcknowledgeTimeOut property.
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void setOptimizeAcknowledgeTimeOut(Long value) {
        this.optimizeAcknowledgeTimeOut = value;
    }

    /**
     * Gets the value of the optimizedAckScheduledAckInterval property.
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    public Long getOptimizedAckScheduledAckInterval() {
        return optimizedAckScheduledAckInterval;
    }

    /**
     * Sets the value of the optimizedAckScheduledAckInterval property.
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void setOptimizedAckScheduledAckInterval(Long value) {
        this.optimizedAckScheduledAckInterval = value;
    }

    /**
     * Gets the value of the optimizedMessageDispatch property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isOptimizedMessageDispatch() {
        return optimizedMessageDispatch;
    }

    /**
     * Sets the value of the optimizedMessageDispatch property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setOptimizedMessageDispatch(Boolean value) {
        this.optimizedMessageDispatch = value;
    }

    /**
     * Gets the value of the password property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPassword() {
        return password;
    }

    /**
     * Sets the value of the password property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setPassword(String value) {
        this.password = value;
    }

    /**
     * Gets the value of the prefetchPolicy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPrefetchPolicy() {
        return prefetchPolicy;
    }

    /**
     * Sets the value of the prefetchPolicy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setPrefetchPolicy(String value) {
        this.prefetchPolicy = value;
    }

    /**
     * Gets the value of the producerWindowSize property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getProducerWindowSize() {
        return producerWindowSize;
    }

    /**
     * Sets the value of the producerWindowSize property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setProducerWindowSize(BigInteger value) {
        this.producerWindowSize = value;
    }

    /**
     * Gets the value of the properties property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getProperties() {
        return properties;
    }

    /**
     * Sets the value of the properties property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setProperties(String value) {
        this.properties = value;
    }

    /**
     * Gets the value of the redeliveryPolicy property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getRedeliveryPolicy() {
        return redeliveryPolicy;
    }

    /**
     * Sets the value of the redeliveryPolicy property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setRedeliveryPolicy(String value) {
        this.redeliveryPolicy = value;
    }

    /**
     * Gets the value of the redeliveryPolicyMap property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getRedeliveryPolicyMap() {
        return redeliveryPolicyMap;
    }

    /**
     * Sets the value of the redeliveryPolicyMap property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setRedeliveryPolicyMap(String value) {
        this.redeliveryPolicyMap = value;
    }

    /**
     * Gets the value of the rejectedTaskHandler property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getRejectedTaskHandler() {
        return rejectedTaskHandler;
    }

    /**
     * Sets the value of the rejectedTaskHandler property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setRejectedTaskHandler(String value) {
        this.rejectedTaskHandler = value;
    }

    /**
     * Gets the value of the rmIdFromConnectionId property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isRmIdFromConnectionId() {
        return rmIdFromConnectionId;
    }

    /**
     * Sets the value of the rmIdFromConnectionId property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setRmIdFromConnectionId(Boolean value) {
        this.rmIdFromConnectionId = value;
    }

    /**
     * Gets the value of the sendAcksAsync property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isSendAcksAsync() {
        return sendAcksAsync;
    }

    /**
     * Sets the value of the sendAcksAsync property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setSendAcksAsync(Boolean value) {
        this.sendAcksAsync = value;
    }

    /**
     * Gets the value of the sendTimeout property.
     * 
     * @return
     *     possible object is
     *     {@link BigInteger }
     *     
     */
    public BigInteger getSendTimeout() {
        return sendTimeout;
    }

    /**
     * Sets the value of the sendTimeout property.
     * 
     * @param value
     *     allowed object is
     *     {@link BigInteger }
     *     
     */
    public void setSendTimeout(BigInteger value) {
        this.sendTimeout = value;
    }

    /**
     * Gets the value of the sessionTaskRunner property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getSessionTaskRunner() {
        return sessionTaskRunner;
    }

    /**
     * Sets the value of the sessionTaskRunner property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setSessionTaskRunner(String value) {
        this.sessionTaskRunner = value;
    }

    /**
     * Gets the value of the statsEnabled property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isStatsEnabled() {
        return statsEnabled;
    }

    /**
     * Sets the value of the statsEnabled property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setStatsEnabled(Boolean value) {
        this.statsEnabled = value;
    }

    /**
     * Gets the value of the transactedIndividualAck property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isTransactedIndividualAck() {
        return transactedIndividualAck;
    }

    /**
     * Sets the value of the transactedIndividualAck property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setTransactedIndividualAck(Boolean value) {
        this.transactedIndividualAck = value;
    }

    /**
     * Gets the value of the transformer property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getTransformer() {
        return transformer;
    }

    /**
     * Sets the value of the transformer property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setTransformer(String value) {
        this.transformer = value;
    }

    /**
     * Gets the value of the transportListener property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getTransportListener() {
        return transportListener;
    }

    /**
     * Sets the value of the transportListener property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setTransportListener(String value) {
        this.transportListener = value;
    }

    /**
     * Gets the value of the trustAllPackages property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isTrustAllPackages() {
        return trustAllPackages;
    }

    /**
     * Sets the value of the trustAllPackages property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setTrustAllPackages(Boolean value) {
        this.trustAllPackages = value;
    }

    /**
     * Gets the value of the useAsyncSend property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseAsyncSend() {
        return useAsyncSend;
    }

    /**
     * Sets the value of the useAsyncSend property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseAsyncSend(Boolean value) {
        this.useAsyncSend = value;
    }

    /**
     * Gets the value of the useBeanNameAsClientIdPrefix property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseBeanNameAsClientIdPrefix() {
        return useBeanNameAsClientIdPrefix;
    }

    /**
     * Sets the value of the useBeanNameAsClientIdPrefix property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseBeanNameAsClientIdPrefix(Boolean value) {
        this.useBeanNameAsClientIdPrefix = value;
    }

    /**
     * Gets the value of the useCompression property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseCompression() {
        return useCompression;
    }

    /**
     * Sets the value of the useCompression property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseCompression(Boolean value) {
        this.useCompression = value;
    }

    /**
     * Gets the value of the useDedicatedTaskRunner property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseDedicatedTaskRunner() {
        return useDedicatedTaskRunner;
    }

    /**
     * Sets the value of the useDedicatedTaskRunner property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseDedicatedTaskRunner(Boolean value) {
        this.useDedicatedTaskRunner = value;
    }

    /**
     * Gets the value of the useRetroactiveConsumer property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isUseRetroactiveConsumer() {
        return useRetroactiveConsumer;
    }

    /**
     * Sets the value of the useRetroactiveConsumer property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setUseRetroactiveConsumer(Boolean value) {
        this.useRetroactiveConsumer = value;
    }

    /**
     * Gets the value of the userName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getUserName() {
        return userName;
    }

    /**
     * Sets the value of the userName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setUserName(String value) {
        this.userName = value;
    }

    /**
     * Gets the value of the warnAboutUnstartedConnectionTimeout property.
     * 
     * @return
     *     possible object is
     *     {@link Long }
     *     
     */
    public Long getWarnAboutUnstartedConnectionTimeout() {
        return warnAboutUnstartedConnectionTimeout;
    }

    /**
     * Sets the value of the warnAboutUnstartedConnectionTimeout property.
     * 
     * @param value
     *     allowed object is
     *     {@link Long }
     *     
     */
    public void setWarnAboutUnstartedConnectionTimeout(Long value) {
        this.warnAboutUnstartedConnectionTimeout = value;
    }

    /**
     * Gets the value of the watchTopicAdvisories property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isWatchTopicAdvisories() {
        return watchTopicAdvisories;
    }

    /**
     * Sets the value of the watchTopicAdvisories property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setWatchTopicAdvisories(Boolean value) {
        this.watchTopicAdvisories = value;
    }

    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setId(String value) {
        this.id = value;
    }

    /**
     * Gets a map that contains attributes that aren't bound to any typed property on this class.
     * 
     * <p>
     * the map is keyed by the name of the attribute and 
     * the value is the string value of the attribute.
     * 
     * the map returned by this method is live, and you can add new attribute
     * by updating the map directly. Because of this design, there's no setter.
     * 
     * 
     * @return
     *     always non-null
     */
    public Map<QName, String> getOtherAttributes() {
        return otherAttributes;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        {
            List<Object> theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
            theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener = (((this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener!= null)&&(!this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener.isEmpty()))?this.getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener():null);
            strategy.appendField(locator, this, "blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener", buffer, theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener);
        }
        {
            Boolean theAlwaysSessionAsync;
            theAlwaysSessionAsync = this.isAlwaysSessionAsync();
            strategy.appendField(locator, this, "alwaysSessionAsync", buffer, theAlwaysSessionAsync);
        }
        {
            Boolean theAlwaysSyncSend;
            theAlwaysSyncSend = this.isAlwaysSyncSend();
            strategy.appendField(locator, this, "alwaysSyncSend", buffer, theAlwaysSyncSend);
        }
        {
            BigInteger theAuditDepth;
            theAuditDepth = this.getAuditDepth();
            strategy.appendField(locator, this, "auditDepth", buffer, theAuditDepth);
        }
        {
            BigInteger theAuditMaximumProducerNumber;
            theAuditMaximumProducerNumber = this.getAuditMaximumProducerNumber();
            strategy.appendField(locator, this, "auditMaximumProducerNumber", buffer, theAuditMaximumProducerNumber);
        }
        {
            String theBeanName;
            theBeanName = this.getBeanName();
            strategy.appendField(locator, this, "beanName", buffer, theBeanName);
        }
        {
            String theBlobTransferPolicy;
            theBlobTransferPolicy = this.getBlobTransferPolicy();
            strategy.appendField(locator, this, "blobTransferPolicy", buffer, theBlobTransferPolicy);
        }
        {
            String theBrokerURL;
            theBrokerURL = this.getBrokerURL();
            strategy.appendField(locator, this, "brokerURL", buffer, theBrokerURL);
        }
        {
            Boolean theCheckForDuplicates;
            theCheckForDuplicates = this.isCheckForDuplicates();
            strategy.appendField(locator, this, "checkForDuplicates", buffer, theCheckForDuplicates);
        }
        {
            String theClientID;
            theClientID = this.getClientID();
            strategy.appendField(locator, this, "clientID", buffer, theClientID);
        }
        {
            String theClientIDPrefix;
            theClientIDPrefix = this.getClientIDPrefix();
            strategy.appendField(locator, this, "clientIDPrefix", buffer, theClientIDPrefix);
        }
        {
            String theClientIdGenerator;
            theClientIdGenerator = this.getClientIdGenerator();
            strategy.appendField(locator, this, "clientIdGenerator", buffer, theClientIdGenerator);
        }
        {
            String theClientInternalExceptionListener;
            theClientInternalExceptionListener = this.getClientInternalExceptionListener();
            strategy.appendField(locator, this, "clientInternalExceptionListener", buffer, theClientInternalExceptionListener);
        }
        {
            BigInteger theCloseTimeout;
            theCloseTimeout = this.getCloseTimeout();
            strategy.appendField(locator, this, "closeTimeout", buffer, theCloseTimeout);
        }
        {
            BigInteger theConnectResponseTimeout;
            theConnectResponseTimeout = this.getConnectResponseTimeout();
            strategy.appendField(locator, this, "connectResponseTimeout", buffer, theConnectResponseTimeout);
        }
        {
            String theConnectionIDPrefix;
            theConnectionIDPrefix = this.getConnectionIDPrefix();
            strategy.appendField(locator, this, "connectionIDPrefix", buffer, theConnectionIDPrefix);
        }
        {
            String theConnectionIdGenerator;
            theConnectionIdGenerator = this.getConnectionIdGenerator();
            strategy.appendField(locator, this, "connectionIdGenerator", buffer, theConnectionIdGenerator);
        }
        {
            Boolean theConsumerExpiryCheckEnabled;
            theConsumerExpiryCheckEnabled = this.isConsumerExpiryCheckEnabled();
            strategy.appendField(locator, this, "consumerExpiryCheckEnabled", buffer, theConsumerExpiryCheckEnabled);
        }
        {
            Long theConsumerFailoverRedeliveryWaitPeriod;
            theConsumerFailoverRedeliveryWaitPeriod = this.getConsumerFailoverRedeliveryWaitPeriod();
            strategy.appendField(locator, this, "consumerFailoverRedeliveryWaitPeriod", buffer, theConsumerFailoverRedeliveryWaitPeriod);
        }
        {
            Boolean theCopyMessageOnSend;
            theCopyMessageOnSend = this.isCopyMessageOnSend();
            strategy.appendField(locator, this, "copyMessageOnSend", buffer, theCopyMessageOnSend);
        }
        {
            Boolean theDisableTimeStampsByDefault;
            theDisableTimeStampsByDefault = this.isDisableTimeStampsByDefault();
            strategy.appendField(locator, this, "disableTimeStampsByDefault", buffer, theDisableTimeStampsByDefault);
        }
        {
            Boolean theDispatchAsync;
            theDispatchAsync = this.isDispatchAsync();
            strategy.appendField(locator, this, "dispatchAsync", buffer, theDispatchAsync);
        }
        {
            String theExceptionListener;
            theExceptionListener = this.getExceptionListener();
            strategy.appendField(locator, this, "exceptionListener", buffer, theExceptionListener);
        }
        {
            Boolean theExclusiveConsumer;
            theExclusiveConsumer = this.isExclusiveConsumer();
            strategy.appendField(locator, this, "exclusiveConsumer", buffer, theExclusiveConsumer);
        }
        {
            BigInteger theMaxThreadPoolSize;
            theMaxThreadPoolSize = this.getMaxThreadPoolSize();
            strategy.appendField(locator, this, "maxThreadPoolSize", buffer, theMaxThreadPoolSize);
        }
        {
            Boolean theMessagePrioritySupported;
            theMessagePrioritySupported = this.isMessagePrioritySupported();
            strategy.appendField(locator, this, "messagePrioritySupported", buffer, theMessagePrioritySupported);
        }
        {
            Boolean theNestedMapAndListEnabled;
            theNestedMapAndListEnabled = this.isNestedMapAndListEnabled();
            strategy.appendField(locator, this, "nestedMapAndListEnabled", buffer, theNestedMapAndListEnabled);
        }
        {
            Boolean theNonBlockingRedelivery;
            theNonBlockingRedelivery = this.isNonBlockingRedelivery();
            strategy.appendField(locator, this, "nonBlockingRedelivery", buffer, theNonBlockingRedelivery);
        }
        {
            Boolean theObjectMessageSerializationDefered;
            theObjectMessageSerializationDefered = this.isObjectMessageSerializationDefered();
            strategy.appendField(locator, this, "objectMessageSerializationDefered", buffer, theObjectMessageSerializationDefered);
        }
        {
            Boolean theOptimizeAcknowledge;
            theOptimizeAcknowledge = this.isOptimizeAcknowledge();
            strategy.appendField(locator, this, "optimizeAcknowledge", buffer, theOptimizeAcknowledge);
        }
        {
            Long theOptimizeAcknowledgeTimeOut;
            theOptimizeAcknowledgeTimeOut = this.getOptimizeAcknowledgeTimeOut();
            strategy.appendField(locator, this, "optimizeAcknowledgeTimeOut", buffer, theOptimizeAcknowledgeTimeOut);
        }
        {
            Long theOptimizedAckScheduledAckInterval;
            theOptimizedAckScheduledAckInterval = this.getOptimizedAckScheduledAckInterval();
            strategy.appendField(locator, this, "optimizedAckScheduledAckInterval", buffer, theOptimizedAckScheduledAckInterval);
        }
        {
            Boolean theOptimizedMessageDispatch;
            theOptimizedMessageDispatch = this.isOptimizedMessageDispatch();
            strategy.appendField(locator, this, "optimizedMessageDispatch", buffer, theOptimizedMessageDispatch);
        }
        {
            String thePassword;
            thePassword = this.getPassword();
            strategy.appendField(locator, this, "password", buffer, thePassword);
        }
        {
            String thePrefetchPolicy;
            thePrefetchPolicy = this.getPrefetchPolicy();
            strategy.appendField(locator, this, "prefetchPolicy", buffer, thePrefetchPolicy);
        }
        {
            BigInteger theProducerWindowSize;
            theProducerWindowSize = this.getProducerWindowSize();
            strategy.appendField(locator, this, "producerWindowSize", buffer, theProducerWindowSize);
        }
        {
            String theProperties;
            theProperties = this.getProperties();
            strategy.appendField(locator, this, "properties", buffer, theProperties);
        }
        {
            String theRedeliveryPolicy;
            theRedeliveryPolicy = this.getRedeliveryPolicy();
            strategy.appendField(locator, this, "redeliveryPolicy", buffer, theRedeliveryPolicy);
        }
        {
            String theRedeliveryPolicyMap;
            theRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
            strategy.appendField(locator, this, "redeliveryPolicyMap", buffer, theRedeliveryPolicyMap);
        }
        {
            String theRejectedTaskHandler;
            theRejectedTaskHandler = this.getRejectedTaskHandler();
            strategy.appendField(locator, this, "rejectedTaskHandler", buffer, theRejectedTaskHandler);
        }
        {
            Boolean theRmIdFromConnectionId;
            theRmIdFromConnectionId = this.isRmIdFromConnectionId();
            strategy.appendField(locator, this, "rmIdFromConnectionId", buffer, theRmIdFromConnectionId);
        }
        {
            Boolean theSendAcksAsync;
            theSendAcksAsync = this.isSendAcksAsync();
            strategy.appendField(locator, this, "sendAcksAsync", buffer, theSendAcksAsync);
        }
        {
            BigInteger theSendTimeout;
            theSendTimeout = this.getSendTimeout();
            strategy.appendField(locator, this, "sendTimeout", buffer, theSendTimeout);
        }
        {
            String theSessionTaskRunner;
            theSessionTaskRunner = this.getSessionTaskRunner();
            strategy.appendField(locator, this, "sessionTaskRunner", buffer, theSessionTaskRunner);
        }
        {
            Boolean theStatsEnabled;
            theStatsEnabled = this.isStatsEnabled();
            strategy.appendField(locator, this, "statsEnabled", buffer, theStatsEnabled);
        }
        {
            Boolean theTransactedIndividualAck;
            theTransactedIndividualAck = this.isTransactedIndividualAck();
            strategy.appendField(locator, this, "transactedIndividualAck", buffer, theTransactedIndividualAck);
        }
        {
            String theTransformer;
            theTransformer = this.getTransformer();
            strategy.appendField(locator, this, "transformer", buffer, theTransformer);
        }
        {
            String theTransportListener;
            theTransportListener = this.getTransportListener();
            strategy.appendField(locator, this, "transportListener", buffer, theTransportListener);
        }
        {
            Boolean theTrustAllPackages;
            theTrustAllPackages = this.isTrustAllPackages();
            strategy.appendField(locator, this, "trustAllPackages", buffer, theTrustAllPackages);
        }
        {
            Boolean theUseAsyncSend;
            theUseAsyncSend = this.isUseAsyncSend();
            strategy.appendField(locator, this, "useAsyncSend", buffer, theUseAsyncSend);
        }
        {
            Boolean theUseBeanNameAsClientIdPrefix;
            theUseBeanNameAsClientIdPrefix = this.isUseBeanNameAsClientIdPrefix();
            strategy.appendField(locator, this, "useBeanNameAsClientIdPrefix", buffer, theUseBeanNameAsClientIdPrefix);
        }
        {
            Boolean theUseCompression;
            theUseCompression = this.isUseCompression();
            strategy.appendField(locator, this, "useCompression", buffer, theUseCompression);
        }
        {
            Boolean theUseDedicatedTaskRunner;
            theUseDedicatedTaskRunner = this.isUseDedicatedTaskRunner();
            strategy.appendField(locator, this, "useDedicatedTaskRunner", buffer, theUseDedicatedTaskRunner);
        }
        {
            Boolean theUseRetroactiveConsumer;
            theUseRetroactiveConsumer = this.isUseRetroactiveConsumer();
            strategy.appendField(locator, this, "useRetroactiveConsumer", buffer, theUseRetroactiveConsumer);
        }
        {
            String theUserName;
            theUserName = this.getUserName();
            strategy.appendField(locator, this, "userName", buffer, theUserName);
        }
        {
            Long theWarnAboutUnstartedConnectionTimeout;
            theWarnAboutUnstartedConnectionTimeout = this.getWarnAboutUnstartedConnectionTimeout();
            strategy.appendField(locator, this, "warnAboutUnstartedConnectionTimeout", buffer, theWarnAboutUnstartedConnectionTimeout);
        }
        {
            Boolean theWatchTopicAdvisories;
            theWatchTopicAdvisories = this.isWatchTopicAdvisories();
            strategy.appendField(locator, this, "watchTopicAdvisories", buffer, theWatchTopicAdvisories);
        }
        {
            String theId;
            theId = this.getId();
            strategy.appendField(locator, this, "id", buffer, theId);
        }
        return buffer;
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = 1;
        {
            List<Object> theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
            theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener = (((this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener!= null)&&(!this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener.isEmpty()))?this.getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener", theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener), currentHashCode, theBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener);
        }
        {
            Boolean theAlwaysSessionAsync;
            theAlwaysSessionAsync = this.isAlwaysSessionAsync();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "alwaysSessionAsync", theAlwaysSessionAsync), currentHashCode, theAlwaysSessionAsync);
        }
        {
            Boolean theAlwaysSyncSend;
            theAlwaysSyncSend = this.isAlwaysSyncSend();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "alwaysSyncSend", theAlwaysSyncSend), currentHashCode, theAlwaysSyncSend);
        }
        {
            BigInteger theAuditDepth;
            theAuditDepth = this.getAuditDepth();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "auditDepth", theAuditDepth), currentHashCode, theAuditDepth);
        }
        {
            BigInteger theAuditMaximumProducerNumber;
            theAuditMaximumProducerNumber = this.getAuditMaximumProducerNumber();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "auditMaximumProducerNumber", theAuditMaximumProducerNumber), currentHashCode, theAuditMaximumProducerNumber);
        }
        {
            String theBeanName;
            theBeanName = this.getBeanName();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "beanName", theBeanName), currentHashCode, theBeanName);
        }
        {
            String theBlobTransferPolicy;
            theBlobTransferPolicy = this.getBlobTransferPolicy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "blobTransferPolicy", theBlobTransferPolicy), currentHashCode, theBlobTransferPolicy);
        }
        {
            String theBrokerURL;
            theBrokerURL = this.getBrokerURL();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "brokerURL", theBrokerURL), currentHashCode, theBrokerURL);
        }
        {
            Boolean theCheckForDuplicates;
            theCheckForDuplicates = this.isCheckForDuplicates();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "checkForDuplicates", theCheckForDuplicates), currentHashCode, theCheckForDuplicates);
        }
        {
            String theClientID;
            theClientID = this.getClientID();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientID", theClientID), currentHashCode, theClientID);
        }
        {
            String theClientIDPrefix;
            theClientIDPrefix = this.getClientIDPrefix();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientIDPrefix", theClientIDPrefix), currentHashCode, theClientIDPrefix);
        }
        {
            String theClientIdGenerator;
            theClientIdGenerator = this.getClientIdGenerator();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientIdGenerator", theClientIdGenerator), currentHashCode, theClientIdGenerator);
        }
        {
            String theClientInternalExceptionListener;
            theClientInternalExceptionListener = this.getClientInternalExceptionListener();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientInternalExceptionListener", theClientInternalExceptionListener), currentHashCode, theClientInternalExceptionListener);
        }
        {
            BigInteger theCloseTimeout;
            theCloseTimeout = this.getCloseTimeout();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "closeTimeout", theCloseTimeout), currentHashCode, theCloseTimeout);
        }
        {
            BigInteger theConnectResponseTimeout;
            theConnectResponseTimeout = this.getConnectResponseTimeout();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "connectResponseTimeout", theConnectResponseTimeout), currentHashCode, theConnectResponseTimeout);
        }
        {
            String theConnectionIDPrefix;
            theConnectionIDPrefix = this.getConnectionIDPrefix();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "connectionIDPrefix", theConnectionIDPrefix), currentHashCode, theConnectionIDPrefix);
        }
        {
            String theConnectionIdGenerator;
            theConnectionIdGenerator = this.getConnectionIdGenerator();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "connectionIdGenerator", theConnectionIdGenerator), currentHashCode, theConnectionIdGenerator);
        }
        {
            Boolean theConsumerExpiryCheckEnabled;
            theConsumerExpiryCheckEnabled = this.isConsumerExpiryCheckEnabled();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "consumerExpiryCheckEnabled", theConsumerExpiryCheckEnabled), currentHashCode, theConsumerExpiryCheckEnabled);
        }
        {
            Long theConsumerFailoverRedeliveryWaitPeriod;
            theConsumerFailoverRedeliveryWaitPeriod = this.getConsumerFailoverRedeliveryWaitPeriod();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "consumerFailoverRedeliveryWaitPeriod", theConsumerFailoverRedeliveryWaitPeriod), currentHashCode, theConsumerFailoverRedeliveryWaitPeriod);
        }
        {
            Boolean theCopyMessageOnSend;
            theCopyMessageOnSend = this.isCopyMessageOnSend();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "copyMessageOnSend", theCopyMessageOnSend), currentHashCode, theCopyMessageOnSend);
        }
        {
            Boolean theDisableTimeStampsByDefault;
            theDisableTimeStampsByDefault = this.isDisableTimeStampsByDefault();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "disableTimeStampsByDefault", theDisableTimeStampsByDefault), currentHashCode, theDisableTimeStampsByDefault);
        }
        {
            Boolean theDispatchAsync;
            theDispatchAsync = this.isDispatchAsync();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "dispatchAsync", theDispatchAsync), currentHashCode, theDispatchAsync);
        }
        {
            String theExceptionListener;
            theExceptionListener = this.getExceptionListener();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "exceptionListener", theExceptionListener), currentHashCode, theExceptionListener);
        }
        {
            Boolean theExclusiveConsumer;
            theExclusiveConsumer = this.isExclusiveConsumer();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "exclusiveConsumer", theExclusiveConsumer), currentHashCode, theExclusiveConsumer);
        }
        {
            BigInteger theMaxThreadPoolSize;
            theMaxThreadPoolSize = this.getMaxThreadPoolSize();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "maxThreadPoolSize", theMaxThreadPoolSize), currentHashCode, theMaxThreadPoolSize);
        }
        {
            Boolean theMessagePrioritySupported;
            theMessagePrioritySupported = this.isMessagePrioritySupported();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "messagePrioritySupported", theMessagePrioritySupported), currentHashCode, theMessagePrioritySupported);
        }
        {
            Boolean theNestedMapAndListEnabled;
            theNestedMapAndListEnabled = this.isNestedMapAndListEnabled();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nestedMapAndListEnabled", theNestedMapAndListEnabled), currentHashCode, theNestedMapAndListEnabled);
        }
        {
            Boolean theNonBlockingRedelivery;
            theNonBlockingRedelivery = this.isNonBlockingRedelivery();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "nonBlockingRedelivery", theNonBlockingRedelivery), currentHashCode, theNonBlockingRedelivery);
        }
        {
            Boolean theObjectMessageSerializationDefered;
            theObjectMessageSerializationDefered = this.isObjectMessageSerializationDefered();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "objectMessageSerializationDefered", theObjectMessageSerializationDefered), currentHashCode, theObjectMessageSerializationDefered);
        }
        {
            Boolean theOptimizeAcknowledge;
            theOptimizeAcknowledge = this.isOptimizeAcknowledge();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "optimizeAcknowledge", theOptimizeAcknowledge), currentHashCode, theOptimizeAcknowledge);
        }
        {
            Long theOptimizeAcknowledgeTimeOut;
            theOptimizeAcknowledgeTimeOut = this.getOptimizeAcknowledgeTimeOut();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "optimizeAcknowledgeTimeOut", theOptimizeAcknowledgeTimeOut), currentHashCode, theOptimizeAcknowledgeTimeOut);
        }
        {
            Long theOptimizedAckScheduledAckInterval;
            theOptimizedAckScheduledAckInterval = this.getOptimizedAckScheduledAckInterval();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "optimizedAckScheduledAckInterval", theOptimizedAckScheduledAckInterval), currentHashCode, theOptimizedAckScheduledAckInterval);
        }
        {
            Boolean theOptimizedMessageDispatch;
            theOptimizedMessageDispatch = this.isOptimizedMessageDispatch();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "optimizedMessageDispatch", theOptimizedMessageDispatch), currentHashCode, theOptimizedMessageDispatch);
        }
        {
            String thePassword;
            thePassword = this.getPassword();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "password", thePassword), currentHashCode, thePassword);
        }
        {
            String thePrefetchPolicy;
            thePrefetchPolicy = this.getPrefetchPolicy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "prefetchPolicy", thePrefetchPolicy), currentHashCode, thePrefetchPolicy);
        }
        {
            BigInteger theProducerWindowSize;
            theProducerWindowSize = this.getProducerWindowSize();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "producerWindowSize", theProducerWindowSize), currentHashCode, theProducerWindowSize);
        }
        {
            String theProperties;
            theProperties = this.getProperties();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "properties", theProperties), currentHashCode, theProperties);
        }
        {
            String theRedeliveryPolicy;
            theRedeliveryPolicy = this.getRedeliveryPolicy();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "redeliveryPolicy", theRedeliveryPolicy), currentHashCode, theRedeliveryPolicy);
        }
        {
            String theRedeliveryPolicyMap;
            theRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "redeliveryPolicyMap", theRedeliveryPolicyMap), currentHashCode, theRedeliveryPolicyMap);
        }
        {
            String theRejectedTaskHandler;
            theRejectedTaskHandler = this.getRejectedTaskHandler();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "rejectedTaskHandler", theRejectedTaskHandler), currentHashCode, theRejectedTaskHandler);
        }
        {
            Boolean theRmIdFromConnectionId;
            theRmIdFromConnectionId = this.isRmIdFromConnectionId();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "rmIdFromConnectionId", theRmIdFromConnectionId), currentHashCode, theRmIdFromConnectionId);
        }
        {
            Boolean theSendAcksAsync;
            theSendAcksAsync = this.isSendAcksAsync();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sendAcksAsync", theSendAcksAsync), currentHashCode, theSendAcksAsync);
        }
        {
            BigInteger theSendTimeout;
            theSendTimeout = this.getSendTimeout();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sendTimeout", theSendTimeout), currentHashCode, theSendTimeout);
        }
        {
            String theSessionTaskRunner;
            theSessionTaskRunner = this.getSessionTaskRunner();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "sessionTaskRunner", theSessionTaskRunner), currentHashCode, theSessionTaskRunner);
        }
        {
            Boolean theStatsEnabled;
            theStatsEnabled = this.isStatsEnabled();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "statsEnabled", theStatsEnabled), currentHashCode, theStatsEnabled);
        }
        {
            Boolean theTransactedIndividualAck;
            theTransactedIndividualAck = this.isTransactedIndividualAck();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transactedIndividualAck", theTransactedIndividualAck), currentHashCode, theTransactedIndividualAck);
        }
        {
            String theTransformer;
            theTransformer = this.getTransformer();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transformer", theTransformer), currentHashCode, theTransformer);
        }
        {
            String theTransportListener;
            theTransportListener = this.getTransportListener();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "transportListener", theTransportListener), currentHashCode, theTransportListener);
        }
        {
            Boolean theTrustAllPackages;
            theTrustAllPackages = this.isTrustAllPackages();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "trustAllPackages", theTrustAllPackages), currentHashCode, theTrustAllPackages);
        }
        {
            Boolean theUseAsyncSend;
            theUseAsyncSend = this.isUseAsyncSend();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "useAsyncSend", theUseAsyncSend), currentHashCode, theUseAsyncSend);
        }
        {
            Boolean theUseBeanNameAsClientIdPrefix;
            theUseBeanNameAsClientIdPrefix = this.isUseBeanNameAsClientIdPrefix();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "useBeanNameAsClientIdPrefix", theUseBeanNameAsClientIdPrefix), currentHashCode, theUseBeanNameAsClientIdPrefix);
        }
        {
            Boolean theUseCompression;
            theUseCompression = this.isUseCompression();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "useCompression", theUseCompression), currentHashCode, theUseCompression);
        }
        {
            Boolean theUseDedicatedTaskRunner;
            theUseDedicatedTaskRunner = this.isUseDedicatedTaskRunner();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "useDedicatedTaskRunner", theUseDedicatedTaskRunner), currentHashCode, theUseDedicatedTaskRunner);
        }
        {
            Boolean theUseRetroactiveConsumer;
            theUseRetroactiveConsumer = this.isUseRetroactiveConsumer();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "useRetroactiveConsumer", theUseRetroactiveConsumer), currentHashCode, theUseRetroactiveConsumer);
        }
        {
            String theUserName;
            theUserName = this.getUserName();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "userName", theUserName), currentHashCode, theUserName);
        }
        {
            Long theWarnAboutUnstartedConnectionTimeout;
            theWarnAboutUnstartedConnectionTimeout = this.getWarnAboutUnstartedConnectionTimeout();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "warnAboutUnstartedConnectionTimeout", theWarnAboutUnstartedConnectionTimeout), currentHashCode, theWarnAboutUnstartedConnectionTimeout);
        }
        {
            Boolean theWatchTopicAdvisories;
            theWatchTopicAdvisories = this.isWatchTopicAdvisories();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "watchTopicAdvisories", theWatchTopicAdvisories), currentHashCode, theWatchTopicAdvisories);
        }
        {
            String theId;
            theId = this.getId();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "id", theId), currentHashCode, theId);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof DtoConnectionFactory)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        final DtoConnectionFactory that = ((DtoConnectionFactory) object);
        {
            List<Object> lhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
            lhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener = (((this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener!= null)&&(!this.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener.isEmpty()))?this.getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener():null);
            List<Object> rhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener;
            rhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener = (((that.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener!= null)&&(!that.blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener.isEmpty()))?that.getBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener", lhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener), LocatorUtils.property(thatLocator, "blobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener", rhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener), lhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener, rhsBlobTransferPolicyOrClientIdGeneratorOrClientInternalExceptionListener)) {
                return false;
            }
        }
        {
            Boolean lhsAlwaysSessionAsync;
            lhsAlwaysSessionAsync = this.isAlwaysSessionAsync();
            Boolean rhsAlwaysSessionAsync;
            rhsAlwaysSessionAsync = that.isAlwaysSessionAsync();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "alwaysSessionAsync", lhsAlwaysSessionAsync), LocatorUtils.property(thatLocator, "alwaysSessionAsync", rhsAlwaysSessionAsync), lhsAlwaysSessionAsync, rhsAlwaysSessionAsync)) {
                return false;
            }
        }
        {
            Boolean lhsAlwaysSyncSend;
            lhsAlwaysSyncSend = this.isAlwaysSyncSend();
            Boolean rhsAlwaysSyncSend;
            rhsAlwaysSyncSend = that.isAlwaysSyncSend();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "alwaysSyncSend", lhsAlwaysSyncSend), LocatorUtils.property(thatLocator, "alwaysSyncSend", rhsAlwaysSyncSend), lhsAlwaysSyncSend, rhsAlwaysSyncSend)) {
                return false;
            }
        }
        {
            BigInteger lhsAuditDepth;
            lhsAuditDepth = this.getAuditDepth();
            BigInteger rhsAuditDepth;
            rhsAuditDepth = that.getAuditDepth();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "auditDepth", lhsAuditDepth), LocatorUtils.property(thatLocator, "auditDepth", rhsAuditDepth), lhsAuditDepth, rhsAuditDepth)) {
                return false;
            }
        }
        {
            BigInteger lhsAuditMaximumProducerNumber;
            lhsAuditMaximumProducerNumber = this.getAuditMaximumProducerNumber();
            BigInteger rhsAuditMaximumProducerNumber;
            rhsAuditMaximumProducerNumber = that.getAuditMaximumProducerNumber();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "auditMaximumProducerNumber", lhsAuditMaximumProducerNumber), LocatorUtils.property(thatLocator, "auditMaximumProducerNumber", rhsAuditMaximumProducerNumber), lhsAuditMaximumProducerNumber, rhsAuditMaximumProducerNumber)) {
                return false;
            }
        }
        {
            String lhsBeanName;
            lhsBeanName = this.getBeanName();
            String rhsBeanName;
            rhsBeanName = that.getBeanName();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "beanName", lhsBeanName), LocatorUtils.property(thatLocator, "beanName", rhsBeanName), lhsBeanName, rhsBeanName)) {
                return false;
            }
        }
        {
            String lhsBlobTransferPolicy;
            lhsBlobTransferPolicy = this.getBlobTransferPolicy();
            String rhsBlobTransferPolicy;
            rhsBlobTransferPolicy = that.getBlobTransferPolicy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "blobTransferPolicy", lhsBlobTransferPolicy), LocatorUtils.property(thatLocator, "blobTransferPolicy", rhsBlobTransferPolicy), lhsBlobTransferPolicy, rhsBlobTransferPolicy)) {
                return false;
            }
        }
        {
            String lhsBrokerURL;
            lhsBrokerURL = this.getBrokerURL();
            String rhsBrokerURL;
            rhsBrokerURL = that.getBrokerURL();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "brokerURL", lhsBrokerURL), LocatorUtils.property(thatLocator, "brokerURL", rhsBrokerURL), lhsBrokerURL, rhsBrokerURL)) {
                return false;
            }
        }
        {
            Boolean lhsCheckForDuplicates;
            lhsCheckForDuplicates = this.isCheckForDuplicates();
            Boolean rhsCheckForDuplicates;
            rhsCheckForDuplicates = that.isCheckForDuplicates();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "checkForDuplicates", lhsCheckForDuplicates), LocatorUtils.property(thatLocator, "checkForDuplicates", rhsCheckForDuplicates), lhsCheckForDuplicates, rhsCheckForDuplicates)) {
                return false;
            }
        }
        {
            String lhsClientID;
            lhsClientID = this.getClientID();
            String rhsClientID;
            rhsClientID = that.getClientID();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientID", lhsClientID), LocatorUtils.property(thatLocator, "clientID", rhsClientID), lhsClientID, rhsClientID)) {
                return false;
            }
        }
        {
            String lhsClientIDPrefix;
            lhsClientIDPrefix = this.getClientIDPrefix();
            String rhsClientIDPrefix;
            rhsClientIDPrefix = that.getClientIDPrefix();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientIDPrefix", lhsClientIDPrefix), LocatorUtils.property(thatLocator, "clientIDPrefix", rhsClientIDPrefix), lhsClientIDPrefix, rhsClientIDPrefix)) {
                return false;
            }
        }
        {
            String lhsClientIdGenerator;
            lhsClientIdGenerator = this.getClientIdGenerator();
            String rhsClientIdGenerator;
            rhsClientIdGenerator = that.getClientIdGenerator();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientIdGenerator", lhsClientIdGenerator), LocatorUtils.property(thatLocator, "clientIdGenerator", rhsClientIdGenerator), lhsClientIdGenerator, rhsClientIdGenerator)) {
                return false;
            }
        }
        {
            String lhsClientInternalExceptionListener;
            lhsClientInternalExceptionListener = this.getClientInternalExceptionListener();
            String rhsClientInternalExceptionListener;
            rhsClientInternalExceptionListener = that.getClientInternalExceptionListener();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientInternalExceptionListener", lhsClientInternalExceptionListener), LocatorUtils.property(thatLocator, "clientInternalExceptionListener", rhsClientInternalExceptionListener), lhsClientInternalExceptionListener, rhsClientInternalExceptionListener)) {
                return false;
            }
        }
        {
            BigInteger lhsCloseTimeout;
            lhsCloseTimeout = this.getCloseTimeout();
            BigInteger rhsCloseTimeout;
            rhsCloseTimeout = that.getCloseTimeout();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "closeTimeout", lhsCloseTimeout), LocatorUtils.property(thatLocator, "closeTimeout", rhsCloseTimeout), lhsCloseTimeout, rhsCloseTimeout)) {
                return false;
            }
        }
        {
            BigInteger lhsConnectResponseTimeout;
            lhsConnectResponseTimeout = this.getConnectResponseTimeout();
            BigInteger rhsConnectResponseTimeout;
            rhsConnectResponseTimeout = that.getConnectResponseTimeout();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "connectResponseTimeout", lhsConnectResponseTimeout), LocatorUtils.property(thatLocator, "connectResponseTimeout", rhsConnectResponseTimeout), lhsConnectResponseTimeout, rhsConnectResponseTimeout)) {
                return false;
            }
        }
        {
            String lhsConnectionIDPrefix;
            lhsConnectionIDPrefix = this.getConnectionIDPrefix();
            String rhsConnectionIDPrefix;
            rhsConnectionIDPrefix = that.getConnectionIDPrefix();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "connectionIDPrefix", lhsConnectionIDPrefix), LocatorUtils.property(thatLocator, "connectionIDPrefix", rhsConnectionIDPrefix), lhsConnectionIDPrefix, rhsConnectionIDPrefix)) {
                return false;
            }
        }
        {
            String lhsConnectionIdGenerator;
            lhsConnectionIdGenerator = this.getConnectionIdGenerator();
            String rhsConnectionIdGenerator;
            rhsConnectionIdGenerator = that.getConnectionIdGenerator();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "connectionIdGenerator", lhsConnectionIdGenerator), LocatorUtils.property(thatLocator, "connectionIdGenerator", rhsConnectionIdGenerator), lhsConnectionIdGenerator, rhsConnectionIdGenerator)) {
                return false;
            }
        }
        {
            Boolean lhsConsumerExpiryCheckEnabled;
            lhsConsumerExpiryCheckEnabled = this.isConsumerExpiryCheckEnabled();
            Boolean rhsConsumerExpiryCheckEnabled;
            rhsConsumerExpiryCheckEnabled = that.isConsumerExpiryCheckEnabled();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "consumerExpiryCheckEnabled", lhsConsumerExpiryCheckEnabled), LocatorUtils.property(thatLocator, "consumerExpiryCheckEnabled", rhsConsumerExpiryCheckEnabled), lhsConsumerExpiryCheckEnabled, rhsConsumerExpiryCheckEnabled)) {
                return false;
            }
        }
        {
            Long lhsConsumerFailoverRedeliveryWaitPeriod;
            lhsConsumerFailoverRedeliveryWaitPeriod = this.getConsumerFailoverRedeliveryWaitPeriod();
            Long rhsConsumerFailoverRedeliveryWaitPeriod;
            rhsConsumerFailoverRedeliveryWaitPeriod = that.getConsumerFailoverRedeliveryWaitPeriod();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "consumerFailoverRedeliveryWaitPeriod", lhsConsumerFailoverRedeliveryWaitPeriod), LocatorUtils.property(thatLocator, "consumerFailoverRedeliveryWaitPeriod", rhsConsumerFailoverRedeliveryWaitPeriod), lhsConsumerFailoverRedeliveryWaitPeriod, rhsConsumerFailoverRedeliveryWaitPeriod)) {
                return false;
            }
        }
        {
            Boolean lhsCopyMessageOnSend;
            lhsCopyMessageOnSend = this.isCopyMessageOnSend();
            Boolean rhsCopyMessageOnSend;
            rhsCopyMessageOnSend = that.isCopyMessageOnSend();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "copyMessageOnSend", lhsCopyMessageOnSend), LocatorUtils.property(thatLocator, "copyMessageOnSend", rhsCopyMessageOnSend), lhsCopyMessageOnSend, rhsCopyMessageOnSend)) {
                return false;
            }
        }
        {
            Boolean lhsDisableTimeStampsByDefault;
            lhsDisableTimeStampsByDefault = this.isDisableTimeStampsByDefault();
            Boolean rhsDisableTimeStampsByDefault;
            rhsDisableTimeStampsByDefault = that.isDisableTimeStampsByDefault();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "disableTimeStampsByDefault", lhsDisableTimeStampsByDefault), LocatorUtils.property(thatLocator, "disableTimeStampsByDefault", rhsDisableTimeStampsByDefault), lhsDisableTimeStampsByDefault, rhsDisableTimeStampsByDefault)) {
                return false;
            }
        }
        {
            Boolean lhsDispatchAsync;
            lhsDispatchAsync = this.isDispatchAsync();
            Boolean rhsDispatchAsync;
            rhsDispatchAsync = that.isDispatchAsync();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "dispatchAsync", lhsDispatchAsync), LocatorUtils.property(thatLocator, "dispatchAsync", rhsDispatchAsync), lhsDispatchAsync, rhsDispatchAsync)) {
                return false;
            }
        }
        {
            String lhsExceptionListener;
            lhsExceptionListener = this.getExceptionListener();
            String rhsExceptionListener;
            rhsExceptionListener = that.getExceptionListener();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "exceptionListener", lhsExceptionListener), LocatorUtils.property(thatLocator, "exceptionListener", rhsExceptionListener), lhsExceptionListener, rhsExceptionListener)) {
                return false;
            }
        }
        {
            Boolean lhsExclusiveConsumer;
            lhsExclusiveConsumer = this.isExclusiveConsumer();
            Boolean rhsExclusiveConsumer;
            rhsExclusiveConsumer = that.isExclusiveConsumer();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "exclusiveConsumer", lhsExclusiveConsumer), LocatorUtils.property(thatLocator, "exclusiveConsumer", rhsExclusiveConsumer), lhsExclusiveConsumer, rhsExclusiveConsumer)) {
                return false;
            }
        }
        {
            BigInteger lhsMaxThreadPoolSize;
            lhsMaxThreadPoolSize = this.getMaxThreadPoolSize();
            BigInteger rhsMaxThreadPoolSize;
            rhsMaxThreadPoolSize = that.getMaxThreadPoolSize();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "maxThreadPoolSize", lhsMaxThreadPoolSize), LocatorUtils.property(thatLocator, "maxThreadPoolSize", rhsMaxThreadPoolSize), lhsMaxThreadPoolSize, rhsMaxThreadPoolSize)) {
                return false;
            }
        }
        {
            Boolean lhsMessagePrioritySupported;
            lhsMessagePrioritySupported = this.isMessagePrioritySupported();
            Boolean rhsMessagePrioritySupported;
            rhsMessagePrioritySupported = that.isMessagePrioritySupported();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "messagePrioritySupported", lhsMessagePrioritySupported), LocatorUtils.property(thatLocator, "messagePrioritySupported", rhsMessagePrioritySupported), lhsMessagePrioritySupported, rhsMessagePrioritySupported)) {
                return false;
            }
        }
        {
            Boolean lhsNestedMapAndListEnabled;
            lhsNestedMapAndListEnabled = this.isNestedMapAndListEnabled();
            Boolean rhsNestedMapAndListEnabled;
            rhsNestedMapAndListEnabled = that.isNestedMapAndListEnabled();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nestedMapAndListEnabled", lhsNestedMapAndListEnabled), LocatorUtils.property(thatLocator, "nestedMapAndListEnabled", rhsNestedMapAndListEnabled), lhsNestedMapAndListEnabled, rhsNestedMapAndListEnabled)) {
                return false;
            }
        }
        {
            Boolean lhsNonBlockingRedelivery;
            lhsNonBlockingRedelivery = this.isNonBlockingRedelivery();
            Boolean rhsNonBlockingRedelivery;
            rhsNonBlockingRedelivery = that.isNonBlockingRedelivery();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "nonBlockingRedelivery", lhsNonBlockingRedelivery), LocatorUtils.property(thatLocator, "nonBlockingRedelivery", rhsNonBlockingRedelivery), lhsNonBlockingRedelivery, rhsNonBlockingRedelivery)) {
                return false;
            }
        }
        {
            Boolean lhsObjectMessageSerializationDefered;
            lhsObjectMessageSerializationDefered = this.isObjectMessageSerializationDefered();
            Boolean rhsObjectMessageSerializationDefered;
            rhsObjectMessageSerializationDefered = that.isObjectMessageSerializationDefered();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "objectMessageSerializationDefered", lhsObjectMessageSerializationDefered), LocatorUtils.property(thatLocator, "objectMessageSerializationDefered", rhsObjectMessageSerializationDefered), lhsObjectMessageSerializationDefered, rhsObjectMessageSerializationDefered)) {
                return false;
            }
        }
        {
            Boolean lhsOptimizeAcknowledge;
            lhsOptimizeAcknowledge = this.isOptimizeAcknowledge();
            Boolean rhsOptimizeAcknowledge;
            rhsOptimizeAcknowledge = that.isOptimizeAcknowledge();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "optimizeAcknowledge", lhsOptimizeAcknowledge), LocatorUtils.property(thatLocator, "optimizeAcknowledge", rhsOptimizeAcknowledge), lhsOptimizeAcknowledge, rhsOptimizeAcknowledge)) {
                return false;
            }
        }
        {
            Long lhsOptimizeAcknowledgeTimeOut;
            lhsOptimizeAcknowledgeTimeOut = this.getOptimizeAcknowledgeTimeOut();
            Long rhsOptimizeAcknowledgeTimeOut;
            rhsOptimizeAcknowledgeTimeOut = that.getOptimizeAcknowledgeTimeOut();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "optimizeAcknowledgeTimeOut", lhsOptimizeAcknowledgeTimeOut), LocatorUtils.property(thatLocator, "optimizeAcknowledgeTimeOut", rhsOptimizeAcknowledgeTimeOut), lhsOptimizeAcknowledgeTimeOut, rhsOptimizeAcknowledgeTimeOut)) {
                return false;
            }
        }
        {
            Long lhsOptimizedAckScheduledAckInterval;
            lhsOptimizedAckScheduledAckInterval = this.getOptimizedAckScheduledAckInterval();
            Long rhsOptimizedAckScheduledAckInterval;
            rhsOptimizedAckScheduledAckInterval = that.getOptimizedAckScheduledAckInterval();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "optimizedAckScheduledAckInterval", lhsOptimizedAckScheduledAckInterval), LocatorUtils.property(thatLocator, "optimizedAckScheduledAckInterval", rhsOptimizedAckScheduledAckInterval), lhsOptimizedAckScheduledAckInterval, rhsOptimizedAckScheduledAckInterval)) {
                return false;
            }
        }
        {
            Boolean lhsOptimizedMessageDispatch;
            lhsOptimizedMessageDispatch = this.isOptimizedMessageDispatch();
            Boolean rhsOptimizedMessageDispatch;
            rhsOptimizedMessageDispatch = that.isOptimizedMessageDispatch();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "optimizedMessageDispatch", lhsOptimizedMessageDispatch), LocatorUtils.property(thatLocator, "optimizedMessageDispatch", rhsOptimizedMessageDispatch), lhsOptimizedMessageDispatch, rhsOptimizedMessageDispatch)) {
                return false;
            }
        }
        {
            String lhsPassword;
            lhsPassword = this.getPassword();
            String rhsPassword;
            rhsPassword = that.getPassword();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "password", lhsPassword), LocatorUtils.property(thatLocator, "password", rhsPassword), lhsPassword, rhsPassword)) {
                return false;
            }
        }
        {
            String lhsPrefetchPolicy;
            lhsPrefetchPolicy = this.getPrefetchPolicy();
            String rhsPrefetchPolicy;
            rhsPrefetchPolicy = that.getPrefetchPolicy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "prefetchPolicy", lhsPrefetchPolicy), LocatorUtils.property(thatLocator, "prefetchPolicy", rhsPrefetchPolicy), lhsPrefetchPolicy, rhsPrefetchPolicy)) {
                return false;
            }
        }
        {
            BigInteger lhsProducerWindowSize;
            lhsProducerWindowSize = this.getProducerWindowSize();
            BigInteger rhsProducerWindowSize;
            rhsProducerWindowSize = that.getProducerWindowSize();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "producerWindowSize", lhsProducerWindowSize), LocatorUtils.property(thatLocator, "producerWindowSize", rhsProducerWindowSize), lhsProducerWindowSize, rhsProducerWindowSize)) {
                return false;
            }
        }
        {
            String lhsProperties;
            lhsProperties = this.getProperties();
            String rhsProperties;
            rhsProperties = that.getProperties();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "properties", lhsProperties), LocatorUtils.property(thatLocator, "properties", rhsProperties), lhsProperties, rhsProperties)) {
                return false;
            }
        }
        {
            String lhsRedeliveryPolicy;
            lhsRedeliveryPolicy = this.getRedeliveryPolicy();
            String rhsRedeliveryPolicy;
            rhsRedeliveryPolicy = that.getRedeliveryPolicy();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "redeliveryPolicy", lhsRedeliveryPolicy), LocatorUtils.property(thatLocator, "redeliveryPolicy", rhsRedeliveryPolicy), lhsRedeliveryPolicy, rhsRedeliveryPolicy)) {
                return false;
            }
        }
        {
            String lhsRedeliveryPolicyMap;
            lhsRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
            String rhsRedeliveryPolicyMap;
            rhsRedeliveryPolicyMap = that.getRedeliveryPolicyMap();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "redeliveryPolicyMap", lhsRedeliveryPolicyMap), LocatorUtils.property(thatLocator, "redeliveryPolicyMap", rhsRedeliveryPolicyMap), lhsRedeliveryPolicyMap, rhsRedeliveryPolicyMap)) {
                return false;
            }
        }
        {
            String lhsRejectedTaskHandler;
            lhsRejectedTaskHandler = this.getRejectedTaskHandler();
            String rhsRejectedTaskHandler;
            rhsRejectedTaskHandler = that.getRejectedTaskHandler();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "rejectedTaskHandler", lhsRejectedTaskHandler), LocatorUtils.property(thatLocator, "rejectedTaskHandler", rhsRejectedTaskHandler), lhsRejectedTaskHandler, rhsRejectedTaskHandler)) {
                return false;
            }
        }
        {
            Boolean lhsRmIdFromConnectionId;
            lhsRmIdFromConnectionId = this.isRmIdFromConnectionId();
            Boolean rhsRmIdFromConnectionId;
            rhsRmIdFromConnectionId = that.isRmIdFromConnectionId();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "rmIdFromConnectionId", lhsRmIdFromConnectionId), LocatorUtils.property(thatLocator, "rmIdFromConnectionId", rhsRmIdFromConnectionId), lhsRmIdFromConnectionId, rhsRmIdFromConnectionId)) {
                return false;
            }
        }
        {
            Boolean lhsSendAcksAsync;
            lhsSendAcksAsync = this.isSendAcksAsync();
            Boolean rhsSendAcksAsync;
            rhsSendAcksAsync = that.isSendAcksAsync();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sendAcksAsync", lhsSendAcksAsync), LocatorUtils.property(thatLocator, "sendAcksAsync", rhsSendAcksAsync), lhsSendAcksAsync, rhsSendAcksAsync)) {
                return false;
            }
        }
        {
            BigInteger lhsSendTimeout;
            lhsSendTimeout = this.getSendTimeout();
            BigInteger rhsSendTimeout;
            rhsSendTimeout = that.getSendTimeout();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sendTimeout", lhsSendTimeout), LocatorUtils.property(thatLocator, "sendTimeout", rhsSendTimeout), lhsSendTimeout, rhsSendTimeout)) {
                return false;
            }
        }
        {
            String lhsSessionTaskRunner;
            lhsSessionTaskRunner = this.getSessionTaskRunner();
            String rhsSessionTaskRunner;
            rhsSessionTaskRunner = that.getSessionTaskRunner();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "sessionTaskRunner", lhsSessionTaskRunner), LocatorUtils.property(thatLocator, "sessionTaskRunner", rhsSessionTaskRunner), lhsSessionTaskRunner, rhsSessionTaskRunner)) {
                return false;
            }
        }
        {
            Boolean lhsStatsEnabled;
            lhsStatsEnabled = this.isStatsEnabled();
            Boolean rhsStatsEnabled;
            rhsStatsEnabled = that.isStatsEnabled();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "statsEnabled", lhsStatsEnabled), LocatorUtils.property(thatLocator, "statsEnabled", rhsStatsEnabled), lhsStatsEnabled, rhsStatsEnabled)) {
                return false;
            }
        }
        {
            Boolean lhsTransactedIndividualAck;
            lhsTransactedIndividualAck = this.isTransactedIndividualAck();
            Boolean rhsTransactedIndividualAck;
            rhsTransactedIndividualAck = that.isTransactedIndividualAck();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transactedIndividualAck", lhsTransactedIndividualAck), LocatorUtils.property(thatLocator, "transactedIndividualAck", rhsTransactedIndividualAck), lhsTransactedIndividualAck, rhsTransactedIndividualAck)) {
                return false;
            }
        }
        {
            String lhsTransformer;
            lhsTransformer = this.getTransformer();
            String rhsTransformer;
            rhsTransformer = that.getTransformer();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transformer", lhsTransformer), LocatorUtils.property(thatLocator, "transformer", rhsTransformer), lhsTransformer, rhsTransformer)) {
                return false;
            }
        }
        {
            String lhsTransportListener;
            lhsTransportListener = this.getTransportListener();
            String rhsTransportListener;
            rhsTransportListener = that.getTransportListener();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "transportListener", lhsTransportListener), LocatorUtils.property(thatLocator, "transportListener", rhsTransportListener), lhsTransportListener, rhsTransportListener)) {
                return false;
            }
        }
        {
            Boolean lhsTrustAllPackages;
            lhsTrustAllPackages = this.isTrustAllPackages();
            Boolean rhsTrustAllPackages;
            rhsTrustAllPackages = that.isTrustAllPackages();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "trustAllPackages", lhsTrustAllPackages), LocatorUtils.property(thatLocator, "trustAllPackages", rhsTrustAllPackages), lhsTrustAllPackages, rhsTrustAllPackages)) {
                return false;
            }
        }
        {
            Boolean lhsUseAsyncSend;
            lhsUseAsyncSend = this.isUseAsyncSend();
            Boolean rhsUseAsyncSend;
            rhsUseAsyncSend = that.isUseAsyncSend();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "useAsyncSend", lhsUseAsyncSend), LocatorUtils.property(thatLocator, "useAsyncSend", rhsUseAsyncSend), lhsUseAsyncSend, rhsUseAsyncSend)) {
                return false;
            }
        }
        {
            Boolean lhsUseBeanNameAsClientIdPrefix;
            lhsUseBeanNameAsClientIdPrefix = this.isUseBeanNameAsClientIdPrefix();
            Boolean rhsUseBeanNameAsClientIdPrefix;
            rhsUseBeanNameAsClientIdPrefix = that.isUseBeanNameAsClientIdPrefix();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "useBeanNameAsClientIdPrefix", lhsUseBeanNameAsClientIdPrefix), LocatorUtils.property(thatLocator, "useBeanNameAsClientIdPrefix", rhsUseBeanNameAsClientIdPrefix), lhsUseBeanNameAsClientIdPrefix, rhsUseBeanNameAsClientIdPrefix)) {
                return false;
            }
        }
        {
            Boolean lhsUseCompression;
            lhsUseCompression = this.isUseCompression();
            Boolean rhsUseCompression;
            rhsUseCompression = that.isUseCompression();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "useCompression", lhsUseCompression), LocatorUtils.property(thatLocator, "useCompression", rhsUseCompression), lhsUseCompression, rhsUseCompression)) {
                return false;
            }
        }
        {
            Boolean lhsUseDedicatedTaskRunner;
            lhsUseDedicatedTaskRunner = this.isUseDedicatedTaskRunner();
            Boolean rhsUseDedicatedTaskRunner;
            rhsUseDedicatedTaskRunner = that.isUseDedicatedTaskRunner();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "useDedicatedTaskRunner", lhsUseDedicatedTaskRunner), LocatorUtils.property(thatLocator, "useDedicatedTaskRunner", rhsUseDedicatedTaskRunner), lhsUseDedicatedTaskRunner, rhsUseDedicatedTaskRunner)) {
                return false;
            }
        }
        {
            Boolean lhsUseRetroactiveConsumer;
            lhsUseRetroactiveConsumer = this.isUseRetroactiveConsumer();
            Boolean rhsUseRetroactiveConsumer;
            rhsUseRetroactiveConsumer = that.isUseRetroactiveConsumer();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "useRetroactiveConsumer", lhsUseRetroactiveConsumer), LocatorUtils.property(thatLocator, "useRetroactiveConsumer", rhsUseRetroactiveConsumer), lhsUseRetroactiveConsumer, rhsUseRetroactiveConsumer)) {
                return false;
            }
        }
        {
            String lhsUserName;
            lhsUserName = this.getUserName();
            String rhsUserName;
            rhsUserName = that.getUserName();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "userName", lhsUserName), LocatorUtils.property(thatLocator, "userName", rhsUserName), lhsUserName, rhsUserName)) {
                return false;
            }
        }
        {
            Long lhsWarnAboutUnstartedConnectionTimeout;
            lhsWarnAboutUnstartedConnectionTimeout = this.getWarnAboutUnstartedConnectionTimeout();
            Long rhsWarnAboutUnstartedConnectionTimeout;
            rhsWarnAboutUnstartedConnectionTimeout = that.getWarnAboutUnstartedConnectionTimeout();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "warnAboutUnstartedConnectionTimeout", lhsWarnAboutUnstartedConnectionTimeout), LocatorUtils.property(thatLocator, "warnAboutUnstartedConnectionTimeout", rhsWarnAboutUnstartedConnectionTimeout), lhsWarnAboutUnstartedConnectionTimeout, rhsWarnAboutUnstartedConnectionTimeout)) {
                return false;
            }
        }
        {
            Boolean lhsWatchTopicAdvisories;
            lhsWatchTopicAdvisories = this.isWatchTopicAdvisories();
            Boolean rhsWatchTopicAdvisories;
            rhsWatchTopicAdvisories = that.isWatchTopicAdvisories();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "watchTopicAdvisories", lhsWatchTopicAdvisories), LocatorUtils.property(thatLocator, "watchTopicAdvisories", rhsWatchTopicAdvisories), lhsWatchTopicAdvisories, rhsWatchTopicAdvisories)) {
                return false;
            }
        }
        {
            String lhsId;
            lhsId = this.getId();
            String rhsId;
            rhsId = that.getId();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "id", lhsId), LocatorUtils.property(thatLocator, "id", rhsId), lhsId, rhsId)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
        return equals(null, null, object, strategy);
    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class BlobTransferPolicy
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.BlobTransferPolicy)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.BlobTransferPolicy that = ((DtoConnectionFactory.BlobTransferPolicy) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class ClientIdGenerator
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.ClientIdGenerator)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.ClientIdGenerator that = ((DtoConnectionFactory.ClientIdGenerator) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class ClientInternalExceptionListener
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.ClientInternalExceptionListener)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.ClientInternalExceptionListener that = ((DtoConnectionFactory.ClientInternalExceptionListener) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class ConnectionIdGenerator
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.ConnectionIdGenerator)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.ConnectionIdGenerator that = ((DtoConnectionFactory.ConnectionIdGenerator) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class ExceptionListener
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.ExceptionListener)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.ExceptionListener that = ((DtoConnectionFactory.ExceptionListener) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;choice minOccurs="0">
     *         &lt;element ref="{http://activemq.apache.org/schema/core}prefetchPolicy"/>
     *         &lt;any namespace='##other'/>
     *       &lt;/choice>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "prefetchPolicy",
        "any"
    })
    public static class PrefetchPolicy
        implements Equals, HashCode, ToString
    {

        protected DtoPrefetchPolicy prefetchPolicy;
        @XmlAnyElement(lax = true)
        protected Object any;

        /**
         * Gets the value of the prefetchPolicy property.
         * 
         * @return
         *     possible object is
         *     {@link DtoPrefetchPolicy }
         *     
         */
        public DtoPrefetchPolicy getPrefetchPolicy() {
            return prefetchPolicy;
        }

        /**
         * Sets the value of the prefetchPolicy property.
         * 
         * @param value
         *     allowed object is
         *     {@link DtoPrefetchPolicy }
         *     
         */
        public void setPrefetchPolicy(DtoPrefetchPolicy value) {
            this.prefetchPolicy = value;
        }

        /**
         * Gets the value of the any property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     
         */
        public Object getAny() {
            return any;
        }

        /**
         * Sets the value of the any property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     
         */
        public void setAny(Object value) {
            this.any = value;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                DtoPrefetchPolicy thePrefetchPolicy;
                thePrefetchPolicy = this.getPrefetchPolicy();
                strategy.appendField(locator, this, "prefetchPolicy", buffer, thePrefetchPolicy);
            }
            {
                Object theAny;
                theAny = this.getAny();
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                DtoPrefetchPolicy thePrefetchPolicy;
                thePrefetchPolicy = this.getPrefetchPolicy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "prefetchPolicy", thePrefetchPolicy), currentHashCode, thePrefetchPolicy);
            }
            {
                Object theAny;
                theAny = this.getAny();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.PrefetchPolicy)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.PrefetchPolicy that = ((DtoConnectionFactory.PrefetchPolicy) object);
            {
                DtoPrefetchPolicy lhsPrefetchPolicy;
                lhsPrefetchPolicy = this.getPrefetchPolicy();
                DtoPrefetchPolicy rhsPrefetchPolicy;
                rhsPrefetchPolicy = that.getPrefetchPolicy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "prefetchPolicy", lhsPrefetchPolicy), LocatorUtils.property(thatLocator, "prefetchPolicy", rhsPrefetchPolicy), lhsPrefetchPolicy, rhsPrefetchPolicy)) {
                    return false;
                }
            }
            {
                Object lhsAny;
                lhsAny = this.getAny();
                Object rhsAny;
                rhsAny = that.getAny();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class Properties
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.Properties)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.Properties that = ((DtoConnectionFactory.Properties) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;choice minOccurs="0">
     *         &lt;element ref="{http://activemq.apache.org/schema/core}redeliveryPolicy"/>
     *         &lt;any namespace='##other'/>
     *       &lt;/choice>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "redeliveryPolicy",
        "any"
    })
    public static class RedeliveryPolicy
        implements Equals, HashCode, ToString
    {

        protected DtoRedeliveryPolicy redeliveryPolicy;
        @XmlAnyElement(lax = true)
        protected Object any;

        /**
         * Gets the value of the redeliveryPolicy property.
         * 
         * @return
         *     possible object is
         *     {@link DtoRedeliveryPolicy }
         *     
         */
        public DtoRedeliveryPolicy getRedeliveryPolicy() {
            return redeliveryPolicy;
        }

        /**
         * Sets the value of the redeliveryPolicy property.
         * 
         * @param value
         *     allowed object is
         *     {@link DtoRedeliveryPolicy }
         *     
         */
        public void setRedeliveryPolicy(DtoRedeliveryPolicy value) {
            this.redeliveryPolicy = value;
        }

        /**
         * Gets the value of the any property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     
         */
        public Object getAny() {
            return any;
        }

        /**
         * Sets the value of the any property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     
         */
        public void setAny(Object value) {
            this.any = value;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                DtoRedeliveryPolicy theRedeliveryPolicy;
                theRedeliveryPolicy = this.getRedeliveryPolicy();
                strategy.appendField(locator, this, "redeliveryPolicy", buffer, theRedeliveryPolicy);
            }
            {
                Object theAny;
                theAny = this.getAny();
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                DtoRedeliveryPolicy theRedeliveryPolicy;
                theRedeliveryPolicy = this.getRedeliveryPolicy();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "redeliveryPolicy", theRedeliveryPolicy), currentHashCode, theRedeliveryPolicy);
            }
            {
                Object theAny;
                theAny = this.getAny();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.RedeliveryPolicy)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.RedeliveryPolicy that = ((DtoConnectionFactory.RedeliveryPolicy) object);
            {
                DtoRedeliveryPolicy lhsRedeliveryPolicy;
                lhsRedeliveryPolicy = this.getRedeliveryPolicy();
                DtoRedeliveryPolicy rhsRedeliveryPolicy;
                rhsRedeliveryPolicy = that.getRedeliveryPolicy();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "redeliveryPolicy", lhsRedeliveryPolicy), LocatorUtils.property(thatLocator, "redeliveryPolicy", rhsRedeliveryPolicy), lhsRedeliveryPolicy, rhsRedeliveryPolicy)) {
                    return false;
                }
            }
            {
                Object lhsAny;
                lhsAny = this.getAny();
                Object rhsAny;
                rhsAny = that.getAny();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;choice minOccurs="0">
     *         &lt;element ref="{http://activemq.apache.org/schema/core}redeliveryPolicyMap"/>
     *         &lt;any namespace='##other'/>
     *       &lt;/choice>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "redeliveryPolicyMap",
        "any"
    })
    public static class RedeliveryPolicyMap
        implements Equals, HashCode, ToString
    {

        protected DtoRedeliveryPolicyMap redeliveryPolicyMap;
        @XmlAnyElement(lax = true)
        protected Object any;

        /**
         * Gets the value of the redeliveryPolicyMap property.
         * 
         * @return
         *     possible object is
         *     {@link DtoRedeliveryPolicyMap }
         *     
         */
        public DtoRedeliveryPolicyMap getRedeliveryPolicyMap() {
            return redeliveryPolicyMap;
        }

        /**
         * Sets the value of the redeliveryPolicyMap property.
         * 
         * @param value
         *     allowed object is
         *     {@link DtoRedeliveryPolicyMap }
         *     
         */
        public void setRedeliveryPolicyMap(DtoRedeliveryPolicyMap value) {
            this.redeliveryPolicyMap = value;
        }

        /**
         * Gets the value of the any property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     
         */
        public Object getAny() {
            return any;
        }

        /**
         * Sets the value of the any property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     
         */
        public void setAny(Object value) {
            this.any = value;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                DtoRedeliveryPolicyMap theRedeliveryPolicyMap;
                theRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
                strategy.appendField(locator, this, "redeliveryPolicyMap", buffer, theRedeliveryPolicyMap);
            }
            {
                Object theAny;
                theAny = this.getAny();
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                DtoRedeliveryPolicyMap theRedeliveryPolicyMap;
                theRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "redeliveryPolicyMap", theRedeliveryPolicyMap), currentHashCode, theRedeliveryPolicyMap);
            }
            {
                Object theAny;
                theAny = this.getAny();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.RedeliveryPolicyMap)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.RedeliveryPolicyMap that = ((DtoConnectionFactory.RedeliveryPolicyMap) object);
            {
                DtoRedeliveryPolicyMap lhsRedeliveryPolicyMap;
                lhsRedeliveryPolicyMap = this.getRedeliveryPolicyMap();
                DtoRedeliveryPolicyMap rhsRedeliveryPolicyMap;
                rhsRedeliveryPolicyMap = that.getRedeliveryPolicyMap();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "redeliveryPolicyMap", lhsRedeliveryPolicyMap), LocatorUtils.property(thatLocator, "redeliveryPolicyMap", rhsRedeliveryPolicyMap), lhsRedeliveryPolicyMap, rhsRedeliveryPolicyMap)) {
                    return false;
                }
            }
            {
                Object lhsAny;
                lhsAny = this.getAny();
                Object rhsAny;
                rhsAny = that.getAny();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class RejectedTaskHandler
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.RejectedTaskHandler)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.RejectedTaskHandler that = ((DtoConnectionFactory.RejectedTaskHandler) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;choice minOccurs="0">
     *         &lt;element ref="{http://activemq.apache.org/schema/core}taskRunnerFactory"/>
     *         &lt;any namespace='##other'/>
     *       &lt;/choice>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "taskRunnerFactory",
        "any"
    })
    public static class SessionTaskRunner
        implements Equals, HashCode, ToString
    {

        protected DtoTaskRunnerFactory taskRunnerFactory;
        @XmlAnyElement(lax = true)
        protected Object any;

        /**
         * Gets the value of the taskRunnerFactory property.
         * 
         * @return
         *     possible object is
         *     {@link DtoTaskRunnerFactory }
         *     
         */
        public DtoTaskRunnerFactory getTaskRunnerFactory() {
            return taskRunnerFactory;
        }

        /**
         * Sets the value of the taskRunnerFactory property.
         * 
         * @param value
         *     allowed object is
         *     {@link DtoTaskRunnerFactory }
         *     
         */
        public void setTaskRunnerFactory(DtoTaskRunnerFactory value) {
            this.taskRunnerFactory = value;
        }

        /**
         * Gets the value of the any property.
         * 
         * @return
         *     possible object is
         *     {@link Object }
         *     
         */
        public Object getAny() {
            return any;
        }

        /**
         * Sets the value of the any property.
         * 
         * @param value
         *     allowed object is
         *     {@link Object }
         *     
         */
        public void setAny(Object value) {
            this.any = value;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                DtoTaskRunnerFactory theTaskRunnerFactory;
                theTaskRunnerFactory = this.getTaskRunnerFactory();
                strategy.appendField(locator, this, "taskRunnerFactory", buffer, theTaskRunnerFactory);
            }
            {
                Object theAny;
                theAny = this.getAny();
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                DtoTaskRunnerFactory theTaskRunnerFactory;
                theTaskRunnerFactory = this.getTaskRunnerFactory();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "taskRunnerFactory", theTaskRunnerFactory), currentHashCode, theTaskRunnerFactory);
            }
            {
                Object theAny;
                theAny = this.getAny();
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.SessionTaskRunner)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.SessionTaskRunner that = ((DtoConnectionFactory.SessionTaskRunner) object);
            {
                DtoTaskRunnerFactory lhsTaskRunnerFactory;
                lhsTaskRunnerFactory = this.getTaskRunnerFactory();
                DtoTaskRunnerFactory rhsTaskRunnerFactory;
                rhsTaskRunnerFactory = that.getTaskRunnerFactory();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "taskRunnerFactory", lhsTaskRunnerFactory), LocatorUtils.property(thatLocator, "taskRunnerFactory", rhsTaskRunnerFactory), lhsTaskRunnerFactory, rhsTaskRunnerFactory)) {
                    return false;
                }
            }
            {
                Object lhsAny;
                lhsAny = this.getAny();
                Object rhsAny;
                rhsAny = that.getAny();
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class Transformer
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.Transformer)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.Transformer that = ((DtoConnectionFactory.Transformer) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class TransportListener
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.TransportListener)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.TransportListener that = ((DtoConnectionFactory.TransportListener) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
     *       &lt;sequence maxOccurs="unbounded" minOccurs="0">
     *         &lt;any maxOccurs="unbounded" minOccurs="0"/>
     *       &lt;/sequence>
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "any"
    })
    public static class TrustedPackages
        implements Equals, HashCode, ToString
    {

        @XmlAnyElement(lax = true)
        protected List<Object> any;

        /**
         * Gets the value of the any property.
         * 
         * <p>
         * This accessor method returns a reference to the live list,
         * not a snapshot. Therefore any modification you make to the
         * returned list will be present inside the JAXB object.
         * This is why there is not a <CODE>set</CODE> method for the any property.
         * 
         * <p>
         * For example, to add a new item, do as follows:
         * <pre>
         *    getAny().add(newItem);
         * </pre>
         * 
         * 
         * <p>
         * Objects of the following type(s) are allowed in the list
         * {@link Object }
         * 
         * 
         */
        public List<Object> getAny() {
            if (any == null) {
                any = new ArrayList<Object>();
            }
            return this.any;
        }

        public String toString() {
            final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
            final StringBuilder buffer = new StringBuilder();
            append(null, buffer, strategy);
            return buffer.toString();
        }

        public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            strategy.appendStart(locator, this, buffer);
            appendFields(locator, buffer, strategy);
            strategy.appendEnd(locator, this, buffer);
            return buffer;
        }

        public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                strategy.appendField(locator, this, "any", buffer, theAny);
            }
            return buffer;
        }

        public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
            int currentHashCode = 1;
            {
                List<Object> theAny;
                theAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "any", theAny), currentHashCode, theAny);
            }
            return currentHashCode;
        }

        public int hashCode() {
            final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
            return this.hashCode(null, strategy);
        }

        public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
            if (!(object instanceof DtoConnectionFactory.TrustedPackages)) {
                return false;
            }
            if (this == object) {
                return true;
            }
            final DtoConnectionFactory.TrustedPackages that = ((DtoConnectionFactory.TrustedPackages) object);
            {
                List<Object> lhsAny;
                lhsAny = (((this.any!= null)&&(!this.any.isEmpty()))?this.getAny():null);
                List<Object> rhsAny;
                rhsAny = (((that.any!= null)&&(!that.any.isEmpty()))?that.getAny():null);
                if (!strategy.equals(LocatorUtils.property(thisLocator, "any", lhsAny), LocatorUtils.property(thatLocator, "any", rhsAny), lhsAny, rhsAny)) {
                    return false;
                }
            }
            return true;
        }

        public boolean equals(Object object) {
            final EqualsStrategy strategy = new org.apache.activemq.plugin.jaxb2_commons.ElementAwareEqualsStrategy();
            return equals(null, null, object, strategy);
        }

    }

}
